#!/usr/bin/bash

# Global variables are always UPPERCASE.
# Local are used with local keyword and lowercase.
# If some function requires too much arguments,
# try using global variables directly, however, this is harder to
# read and debug.

function ScriptInfo() {
  DATE="2025"
  VERSION="0.0.2"
  GH_URL="https://github.com/tcaceresm/AmberMCPBHelper"

  cat <<EOF
###################################################
 Welcome to combine.sh version ${VERSION} ${DATE}   
  Author: Tomás Cáceres <caceres.tomas@uc.cl>
  Laboratory of Computational simulation & drug design        
  GitHub <${GH_URL}>                             
  Powered by high fat food and procrastination   
###################################################
EOF
}

Help() {
  ScriptInfo
  echo -e "\nUsage: bash combine.sh OPTIONS\n"
  echo "MCPB.py create two residues to describe the metallorganic compound."
  echo "This script merge into one residue comprising both the metal and the organic fragment."
  echo "Required files: "
  echo "  -frcmod files (generated by MCPB.py step 2)"
  echo "  -metal.mol2 and lig.mol2 (both generated by MCPB.py step 3)."

  echo "You MUST run prepare4mcpb.sh and run_mcpb.sh first!"

  echo "Required options:"
  echo " -d, --work_dir         <path>       Working directory. Inside this directory, a folder named setupMD will be created which contains all necessary files."
  echo " -i, --input_file       <str>        MCPB input file."
  echo "Optional:"
  echo " -h, --help                          Show this help."

}

# Check arguments
if [[ "$#" == 0 ]]; then
  echo "Error: No options provided."
  echo "Use --help option to check available options."
  exit 1
fi

# Default values

# CLI option parser
while [[ $# -gt 0 ]]; do
  case "$1" in
  '-d' | '--work_dir'        ) shift ; WDPATH=$1 ;;
  '--input_file' | '-i'      ) shift ; INPUT_FILE=$1 ;;
  '--ext_qm'                 ) EXT_QM=1 ;;
  '--help' | '-h'            ) Help ; exit 0 ;;
  *                          ) echo "Unrecognized command line option: $1" >> /dev/stderr ; exit 1 ;;
  esac
  shift
done

#### Functions ####

function CheckProgram() {
  for COMMAND in "$@"; do
    # Check if command is available
    if ! command -v ${1} >/dev/null 2>&1; then
      echo "Error: ${1} not available, exiting."
      exit 1
    fi
  done
}

function CheckFiles() {
  # Check existence of files
  for ARG in "$@"; do
    if [[ ! -f ${ARG} ]]; then
      echo "Error: ${ARG} file doesn't exist."
      exit 1
    fi
  done
}

function CheckVariable() {
  # Check if variable is not empty
  for ARG in "$@"; do
    if [[ -z "${ARG// /}" ]]; then
      echo "Error: Required option not provided or empty."
      echo "Use --help option to check available options."
      exit 1
  fi
  done
}

function ParseName() {
  # Obtain actual file used by MCPB.py from MCPB.in
  local input_file=$1

  ORIGINAL_PDB=$(awk '
  /original_pdb/ { print $2 }
  ' ${input_file})

  ORIGINAL_PDB_NAME=$(basename ${ORIGINAL_PDB} .pdb)

  echo -e "Original pdb in ${input_file} is ${ORIGINAL_PDB}.\n"

}

function FindMol2Files() {
  # Find mol2 files generated by MCPB step 3.
  local input_file=$1

  # Global variable
  MOL2_FILES=($(grep -oE '^[*]+Generating the [A-Za-z0-9_]+\.mol2' ${input_file} | awk '{print $3}'))

  if [[ ${#MOL2_FILES[@]} != 2 ]]; then
    echo "Error in FindMol2Files: Expected 2 .mol2 files. Got ${#MOL2_FILES[@]}"
    exit 1
  fi
  echo "Found ${#MOL2_FILES[@]} mol2 files generated by MCPB in ${input_file}."
  echo "Names are ${MOL2_FILES[@]}"
  echo -e "Done.\n"

}

function ExtractLeaprc() {
    local input_file="$1"
    local output_file="$2"

    # Captura todas las líneas que empiezan con "source leaprc"
    grep '^source leaprc' ${input_file} > ${output_file}
    echo "source leaprc.gaff2" >> ${output_file}
}


function ExtractHybridizationData() {
  # From tleap created by MCPB.py
  local input_file=$1
  local output_file=$2

  # /pattern1/,/patter2/ --> range of lines
  # so, match starting "addAtomTypes {" lines to a line that contains only a "}" (starts with } and ends with })

  awk '/addAtomTypes {/,/^}$/ {print}' ${input_file} >> ${output_file}
  awk '/addAtomTypes {/,/^}$/ {print}' ${input_file} > HYBRIDIZATION.data
}

function ExtractLoadmol2() {
    local input_file=$1
    local output_file=$2

    # These should match to FindMol2Files
    grep '\.mol2$' ${input_file} >> ${output_file}
}

function ExtractLoadamberparams() {
    local input_file=$1
    local output_file=$2

    grep '^loadamberparams' ${input_file} >> ${output_file}
}

function CreateCombineLeap() {
  # First, we extract data from tleap created by MCPB
  # in order to match ff, hybridization data, etc
  local input_file=$1
  local output_file=$2

  ExtractLeaprc ${input_file} ${output_file} # ff
  ExtractHybridizationData ${input_file} ${output_file} # Hybridization data
  ExtractLoadmol2 ${input_file} ${output_file} # MOL2 used
  ExtractLoadamberparams ${input_file} ${output_file} # frcmods

  local mol1=$(basename ${MOL2_FILES[0]} .mol2)
  local mol2=$(basename ${MOL2_FILES[1]} .mol2)

  cat >> ${output_file}<<EOF
saveamberparm ${mol1} ${mol1}.parm7 ${mol1}.rst7
saveamberparm ${mol2} ${mol2}.parm7 ${mol2}.rst7
quit
EOF

}

function CreateCombineCpptraj() {
  # Merge mol2 files
  local output_file=$1
  local mol1=$(basename ${MOL2_FILES[0]} .mol2)
  local mol2=$(basename ${MOL2_FILES[1]} .mol2)

  cat > ${output_file} <<EOF
parm ${mol1}.parm7
parm ${mol2}.parm7

loadcrd ${mol1}.mol2 parmindex 0 name CRD1
loadcrd ${mol2}.mol2 parmindex 1 name CRD2

combinecrd CRD1 CRD2 parmname Parm-1-2 crdname CRD-1-2

crdout CRD-1-2 LIGAND.mol2
run
quit
EOF

  CheckProgram "cpptraj"

  cpptraj -i ${output_file}

}

function ProcessMOL2() {
  # Need to do some cleaning:
  # -> all resname to LIG1
  # -> all resid to 1
  # -> fix mol2 format
  
  INPUT="LIGAND.mol2"
  OUTPUT="LIGAND_renamed.mol2"

  # Find the line containing "ATOM" → set flag f to 1 and skip printing that line (next).
  # While f == 1 → print all subsequent lines.
  # Find the line containing "BOND" → reset flag f to 0 (f = 0) → stop printing.
  # Everything else outside this range will not be printed.

  # ? fix resname and resid
  awk '
    /^@<TRIPOS>ATOM/{f=1; print; next}       # ATOM section
    /^@<TRIPOS>BOND/{f=0}             # Fin sección ATOM
    f {
        resid = 1
        resname = "LIG"

        # substr($0, start, length)
        $0 = substr($0,1,58) sprintf("%4d %s", resid, resname) substr($0,64)
        print
        next
    }
    { print }                                  
  ' ${INPUT} > ${OUTPUT} || { echo "ERROR"; exit 1; }

  # fix tripos molecule
  awk '
  NR==3 { $0 = substr($0,1,16) 1 substr($0,18) } 
  { print }
  ' ${OUTPUT} > ${OUTPUT}.tmp && mv ${OUTPUT}.tmp ${OUTPUT}

  # fix substructure
  awk '
    /^@<TRIPOS>SUBSTRUCTURE/ { print; f=1; next }  
    f { f--; next }                             
    { print }                                        
  ' ${OUTPUT} > ${OUTPUT}.tmp && mv ${OUTPUT}.tmp ${OUTPUT} || { echo "ERROR"; exit 1; }

  awk '
    /^@<TRIPOS>SUBSTRUCTURE/ { f=1; print; next }

    f {
      $0 = substr($0,1,8) "LIG" substr($0,12,28)
      print $0
      next
    }
    { print }
  ' "${OUTPUT}" > ${OUTPUT}.tmp && mv ${OUTPUT}.tmp ${OUTPUT} || { echo "ERROR"; exit 1; }

}

function ExtractBonds() {
  # From tleap created by MCPB.py
  local input_file=$1
  local output_file=$2

  # /pattern1/,/patter2/ --> range of lines
  # so, match starting "addAtomTypes {" lines to a line that contains only a "}" (starts with } and ends with })

  awk '/^bond/ {print}' ${input_file} >> ${output_file}

}

function CreateFinalLeap() {
  # First, we extract data from tleap created by MCPB
  # in order to match ff, hybridization data, etc
  local input_file=$1
  local output_file=$2

  echo "Creating ${output_file} to obtain relevant files"

  ExtractLeaprc ${input_file} ${output_file} # ff
  ExtractHybridizationData ${input_file} ${output_file} # Hybridization data
  ExtractLoadamberparams ${input_file} ${output_file} # frcmods

  cat >> ${output_file} <<EOF
LIG = loadmol2 LIGAND_renamed.mol2

EOF
  ExtractBonds ${input_file} ${output_file}

  sed -i 's/mol\.1/LIG.1/g' ${output_file}
  sed -i 's/mol\.2/LIG.1/g' ${output_file}

  cat >> ${output_file} <<EOF

set LIG name "LIG"
saveoff LIG LIG.lib
saveamberparm LIG LIG.parm7 LIG.rst7

savepdb LIG LIG.pdb

quit
EOF
  echo -e "Done.\n"
}

### End functions ####

#### Main ####
CheckVariable "${WDPATH}" "${INPUT_FILE}"
CheckFiles ${INPUT_FILE}

ParseName ${INPUT_FILE}

FindMol2Files "LIG_MCPB_step3.log"

CreateCombineLeap "${ORIGINAL_PDB_NAME}_tleap.in" "${ORIGINAL_PDB_NAME}_combine.in"

CheckProgram "tleap"

tleap -f "${ORIGINAL_PDB_NAME}_combine.in" || { echo "Error running tleap and ${ORIGINAL_PDB_NAME}_combine.in file"; exit 1; }

CreateCombineCpptraj "combine_mol2_cpptraj.in"

ProcessMOL2

CreateFinalLeap "${ORIGINAL_PDB_NAME}_tleap.in" "final_leap.in"

tleap -f final_leap.in || { echo "Error running final_leap.in. Exiting."; exit 1; }

echo -e "Making relevant_files directory.\n" 
mkdir -p "relevant_files"

echo -e "Copying relevant files to relevant_files directory.\n"
cp LIG.lib HYBRIDIZATION.data ${ORIGINAL_PDB_NAME}_mcpbpy.frcmod \
   LIG.pdb LIG.parm7 LIG.rst7 LIG.frcmod relevant_files

echo "Done running combine.sh!"

#### End Main ####