#!/usr/bin/bash

# Global variables are always UPPERCASE.
# Local are used with local keyword and lowercase.
# If some function requires too much arguments,
# try using global variables directly, however, this is harder to
# read and debug.

function ScriptInfo() {
  DATE="2025"
  VERSION="0.0.1"
  GH_URL="https://github.com/tcaceresm/AmberMCPBHelper"

  cat <<EOF
###################################################
 Welcome to run_mcpb version ${VERSION} ${DATE}   
  Author: Tomás Cáceres <caceres.tomas@uc.cl>
  Laboratory of Computational simulation & drug design        
  GitHub <${GH_URL}>                             
  Powered by high fat food and procrastination   
###################################################
EOF
}

Help() {
  ScriptInfo
  echo -e "\nUsage: bash run_mcpb.sh OPTIONS\n"
  echo "This script run MCPB.py."
  echo "You MUST run prepare4mcpb.sh first."

  echo "Required options:"
  echo " -d, --work_dir         <path>       Working directory. Inside this directory, a folder named setupMD will be created which contains all necessary files."
  echo " -i, --input_file       <str>        MCPB input file."
  echo "Optional:"
  echo " --ext_qm                            Using external QM output files. This option just trigger some checks."
  echo " -h, --help                          Show this help."

}

# Check arguments
if [[ "$#" == 0 ]]; then
  echo "Error: No options provided."
  echo "Use --help option to check available options."
  exit 1
fi

# Default values

# CLI option parser
while [[ $# -gt 0 ]]; do
  case "$1" in
  '-d' | '--work_dir'        ) shift ; WDPATH=$1 ;;
  '--input_file' | '-i'      ) shift ; INPUT_FILE=$1 ;;
  '--ext_qm'                 ) EXT_QM=1 ;;
  '--help' | '-h'            ) Help ; exit 0 ;;
  *                          ) echo "Unrecognized command line option: $1" >> /dev/stderr ; exit 1 ;;
  esac
  shift
done

#### Functions ####

function CheckProgram() {
  for COMMAND in "$@"; do
    # Check if command is available
    if ! command -v ${1} >/dev/null 2>&1; then
      echo "Error: ${1} not available, exiting."
      exit 1
    fi
  done
}

function CheckFiles() {
  # Check existence of files
  for ARG in "$@"; do
    if [[ ! -f ${ARG} ]]; then
      echo "Error: ${ARG} file doesn't exist."
      exit 1
    fi
  done
}

function CheckVariable() {
  # Check if variable is not empty
  for ARG in "$@"; do
    if [[ -z "${ARG// /}" ]]; then
      echo "Error: Required option not provided or empty."
      echo "Use --help option to check available options."
      exit 1
  fi
  done
}

function ParseName() {
  # Obtain actual file used by MCPB.py from MCPB.in
  local input_file=$1

  ORIGINAL_PDB=$(awk '
  /original_pdb/ { print $2 }
  ' ${input_file})

  ORIGINAL_PDB_NAME=$(basename ${ORIGINAL_PDB} .pdb)

}

function Step1() {
  # MCPB step 1
  local input_file=$1
  local input_filename=$(basename ${input_file} .in)

  echo -e "Starting step 1.\n"
  MCPB.py -i ${input_file} -s 1 > ${input_filename}_step1.log \
  || { echo "Error during step 1. Exiting"; exit 1; }

  # Sanity Checks

  # Check. *_small.pdb should be the same than original pdb
  # An issue here is more probable when using a QM output file not using
  # MCPB input files.

  #diff <(awk '/ATOM|HETATM/ {printf "%s\n", substr($0,1,20)}' "${ORIGINAL_PDB}") \
  #   <(awk '/ATOM|HETATM/ {printf "%s\n", substr($0,1,20)}' "${ORIGINAL_PDB_NAME}_small.pdb")
  

  # Maybe add a flag if external QM output files were used
  if [[ ${EXT_QM} -eq 1 ]]; then
    diff <(awk '/ATOM|HETATM/ {print $1 $2 $3 $4}' "${ORIGINAL_PDB}") \
      <(awk '/ATOM|HETATM/ {print $1 $2 $3 $4}' "${ORIGINAL_PDB_NAME}_small.pdb")

    if [[ $? -eq 0 ]]; then
      echo "${ORIGINAL_PDB} and ${ORIGINAL_PDB_NAME}_small.pdb files are similar in atom ordering.
  There shouldn't be a problem by using manual QM output files not generated by MCPB.py."
    elif [[ $? -eq 1 ]]; then
      echo "${ORIGINAL_PDB} and ${ORIGINAL_PDB_NAME}_small.pdb files are different in atom ordering.
  There should be a problem by using manual QM output files not generated by MCPB.py."
    else
      echo "An error occurred while comparing files."
    fi
  fi

  if sort "${ORIGINAL_PDB_NAME}_standard.fingerprint" | uniq -d | grep -q .; then
    echo "Duplicated entries in ${ORIGINAL_PDB_NAME}_standard.fingerprint."
    local duplicates=1
  fi
  
  if [[ ${duplicates} -eq 1 ]]; then
    echo "Fixing duplicated LINK records in ${ORIGINAL_PDB_NAME}_standard.fingerprint."
    sort -u ${ORIGINAL_PDB_NAME}_standard.fingerprint > tmp_file && \
    mv tmp_file ${ORIGINAL_PDB_NAME}_standard.fingerprint
    echo -e "Fixed.\n"
  fi

  if sort "${ORIGINAL_PDB_NAME}_standard.fingerprint" | uniq -d | grep -q .; then
    echo "Still duplicated entries in ${ORIGINAL_PDB_NAME}_standard.fingerprint. Exiting"
    exit 1
  fi

  echo -e "End step 1.\n"
}

function Step2() {
  # MCPB step 2
  local input_file=$1
  local input_filename=$(basename ${input_file} .in)

  echo -e "Starting step 2.\n"
  MCPB.py -i ${input_file} -s 2 &> ${input_filename}_step2.log \
  || { echo "Error during step 2. Exiting"; exit 1; }

  # Sanity Checks

  # -q: quiet, -i: case-insensitive
  if grep -qi 'nan' "${ORIGINAL_PDB_NAME}_mcpbpy.frcmod"; then
      echo "Error: ${ORIGINAL_PDB_NAME}_mcpbpy.frcmod file contains NaN values"
      exit 1
  fi

  echo -e "End step 2.\n"
}

function Step3() {
  # MCPB step 3
  local input_file=$1
  local input_filename=$(basename ${input_file} .in)

  echo -e "Starting step 3.\n"
  MCPB.py -i ${input_file} -s 3 &> ${input_filename}_step3.log \
  || { echo "Error during step 3. Exiting"; exit 1; }

  # Sanity Checks

  echo -e "End step 3.\n"
}

function Step4() {
  # MCPB step 4
  local input_file=$1
  local input_filename=$(basename ${input_file} .in)

  echo -e "Starting step 4.\n"
  MCPB.py -i ${input_file} -s 4 &> ${input_filename}_step4.log \
  || { echo "Error during step 4. Exiting"; exit 1; }

  # Sanity Checks

  echo -e "End step 4.\n"
}


#### End functions ####


#### Main ####
CheckProgram "MCPB.py"
CheckVariable "${WDPATH}" "${INPUT_FILE}"
CheckFiles ${INPUT_FILE}

ParseName ${INPUT_FILE}

Step1 ${INPUT_FILE}
Step2 ${INPUT_FILE}
Step3 ${INPUT_FILE}
Step4 ${INPUT_FILE}

echo "Done running run_mcpb.sh!"

#### End Main ####